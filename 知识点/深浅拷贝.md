# 深浅拷贝详解

## 一、什么是拷贝？

**拷贝** 就是复制一个对象。在C++中，拷贝分为两种：
- **浅拷贝**：只复制指针，不复制指针指向的数据
- **深拷贝**：复制指针，并且复制指针指向的数据

```cpp
#include <iostream>
#include <cstring>

class ShallowCopy {
private:
    char* data;
    
public:
    ShallowCopy(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }
    
    ~ShallowCopy() {
        delete[] data;
    }
    
    void display() {
        std::cout << "数据: " << data << std::endl;
    }
    
    void setData(const char* str) {
        strcpy(data, str);
    }
};

void shallow_copy_problem() {
    ShallowCopy obj1("Hello");
    ShallowCopy obj2 = obj1;  // 默认拷贝构造函数：浅拷贝！
    
    std::cout << "修改前：" << std::endl;
    obj1.display();  // Hello
    obj2.display();  // Hello
    
    obj2.setData("World");
    
    std::cout << "\n修改obj2为World后：" << std::endl;
    obj1.display();  // World！obj1也被修改了
    obj2.display();  // World
    
    // 更严重的问题：双重释放！
    // obj1和obj2析构时都会delete[]同一个内存
}
```

## 二、为什么会有深浅拷贝问题？

```cpp
// 问题演示
class Problem {
private:
    int* array;
    int size;
    
public:
    Problem(int n) : size(n) {
        array = new int[size];
        for (int i = 0; i < size; i++) {
            array[i] = i + 1;
        }
    }
    
    ~Problem() {
        delete[] array;
    }
    
    void show() {
        std::cout << "数组: ";
        for (int i = 0; i < size; i++) {
            std::cout << array[i] << " ";
        }
        std::cout << std::endl;
    }
    
    void modify(int index, int value) {
        if (index >= 0 && index < size) {
            array[index] = value;
        }
    }
};

void demo_problem() {
    Problem p1(5);
    Problem p2 = p1;  // 浅拷贝！
    
    std::cout << "初始状态：" << std::endl;
    p1.show();  // 1 2 3 4 5
    p2.show();  // 1 2 3 4 5
    
    p2.modify(2, 100);
    
    std::cout << "\n修改p2[2] = 100后：" << std::endl;
    p1.show();  // 1 2 100 4 5  p1也被修改了！
    p2.show();  // 1 2 100 4 5
    
    // 程序结束时：
    // 1. p2先析构，释放array内存
    // 2. p1再析构，再次释放同一块内存 → 程序崩溃！
}
```

## 三、C++默认的拷贝行为

### 1. **默认拷贝构造函数**

```cpp
class DefaultCopy {
private:
    int value;       // 基本类型：值拷贝
    int* pointer;    // 指针类型：指针值拷贝（浅拷贝）
    int array[5];    // 数组：元素逐个拷贝（深拷贝）
    
public:
    DefaultCopy(int v) : value(v) {
        pointer = new int(v * 2);
        for (int i = 0; i < 5; i++) {
            array[i] = i;
        }
    }
    
    // 默认拷贝构造函数大致相当于：
    // DefaultCopy(const DefaultCopy& other) 
    //     : value(other.value), pointer(other.pointer) {  // 问题在这里！
    //     for (int i = 0; i < 5; i++) {
    //         array[i] = other.array[i];
    //     }
    // }
    
    ~DefaultCopy() {
        delete pointer;
    }
    
    void setPointer(int v) {
        *pointer = v;
    }
    
    void show() {
        std::cout << "value: " << value 
                  << ", pointer: " << *pointer
                  << ", array[0]: " << array[0] << std::endl;
    }
};
```

### 2. **默认赋值运算符**

```cpp
class DefaultAssignment {
private:
    char* name;
    
public:
    DefaultAssignment(const char* str) {
        name = new char[strlen(str) + 1];
        strcpy(name, str);
    }
    
    // 默认赋值运算符大致相当于：
    // DefaultAssignment& operator=(const DefaultAssignment& other) {
    //     name = other.name;  // 浅拷贝！
    //     return *this;
    // }
    
    ~DefaultAssignment() {
        delete[] name;
    }
    
    void setName(const char* str) {
        strcpy(name, str);
    }
    
    const char* getName() const {
        return name;
    }
};

void assignment_problem() {
    DefaultAssignment a1("Alice");
    DefaultAssignment a2("Bob");
    
    std::cout << "赋值前：" << std::endl;
    std::cout << "a1: " << a1.getName() << std::endl;  // Alice
    std::cout << "a2: " << a2.getName() << std::endl;  // Bob
    
    a2 = a1;  // 默认赋值运算符：浅拷贝！
    
    std::cout << "\n赋值a2 = a1后：" << std::endl;
    std::cout << "a1: " << a1.getName() << std::endl;  // Alice
    std::cout << "a2: " << a2.getName() << std::endl;  // Alice
    
    a2.setName("Charlie");
    
    std::cout << "\n修改a2为Charlie后：" << std::endl;
    std::cout << "a1: " << a1.getName() << std::endl;  // Charlie！a1也被修改
    std::cout << "a2: " << a2.getName() << std::endl;  // Charlie
    
    // 问题：
    // 1. a1和a2共享同一块内存
    // 2. "Bob"的内存泄漏了
    // 3. 双重释放
}
```

## 四、实现深拷贝

### 1. **拷贝构造函数深拷贝**

```cpp
class DeepCopyConstructor {
private:
    char* data;
    int length;
    
public:
    // 构造函数
    DeepCopyConstructor(const char* str) {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        std::cout << "构造函数调用" << std::endl;
    }
    
    // 深拷贝构造函数
    DeepCopyConstructor(const DeepCopyConstructor& other) {
        length = other.length;
        data = new char[length + 1];  // 重新分配内存
        strcpy(data, other.data);     // 复制数据
        
        std::cout << "深拷贝构造函数调用" << std::endl;
    }
    
    // 析构函数
    ~DeepCopyConstructor() {
        delete[] data;
        std::cout << "析构函数调用" << std::endl;
    }
    
    // 显示数据
    void display() const {
        std::cout << "长度: " << length << ", 数据: " << data << std::endl;
    }
    
    // 修改数据
    void setData(const char* str) {
        delete[] data;  // 释放旧内存
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }
};

void test_deep_copy_constructor() {
    DeepCopyConstructor obj1("Hello World");
    DeepCopyConstructor obj2 = obj1;  // 调用深拷贝构造函数
    
    std::cout << "\n初始状态：" << std::endl;
    obj1.display();  // 长度: 11, 数据: Hello World
    obj2.display();  // 长度: 11, 数据: Hello World
    
    obj2.setData("Changed");
    
    std::cout << "\n修改obj2后：" << std::endl;
    obj1.display();  // 长度: 11, 数据: Hello World  ✓ 不受影响
    obj2.display();  // 长度: 7, 数据: Changed
    
    // 不会双重释放，因为每个对象有自己的内存
}
```

### 2. **赋值运算符深拷贝**

```cpp
class DeepCopyAssignment {
private:
    int* numbers;
    int size;
    
public:
    // 构造函数
    DeepCopyAssignment(int n) : size(n) {
        numbers = new int[size];
        for (int i = 0; i < size; i++) {
            numbers[i] = i + 1;
        }
        std::cout << "构造函数，大小: " << size << std::endl;
    }
    
    // 深拷贝构造函数
    DeepCopyAssignment(const DeepCopyAssignment& other) 
        : size(other.size) {
        numbers = new int[size];
        for (int i = 0; i < size; i++) {
            numbers[i] = other.numbers[i];
        }
        std::cout << "深拷贝构造函数" << std::endl;
    }
    
    // 深拷贝赋值运算符
    DeepCopyAssignment& operator=(const DeepCopyAssignment& other) {
        std::cout << "深拷贝赋值运算符" << std::endl;
        
        // 1. 检查自赋值
        if (this == &other) {
            return *this;
        }
        
        // 2. 释放原有资源
        delete[] numbers;
        
        // 3. 分配新资源
        size = other.size;
        numbers = new int[size];
        
        // 4. 复制数据
        for (int i = 0; i < size; i++) {
            numbers[i] = other.numbers[i];
        }
        
        // 5. 返回当前对象引用
        return *this;
    }
    
    // 析构函数
    ~DeepCopyAssignment() {
        delete[] numbers;
        std::cout << "析构函数" << std::endl;
    }
    
    // 显示
    void display() const {
        std::cout << "大小: " << size << ", 数据: ";
        for (int i = 0; i < size; i++) {
            std::cout << numbers[i] << " ";
        }
        std::cout << std::endl;
    }
    
    // 修改
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            numbers[index] = value;
        }
    }
};

void test_deep_copy_assignment() {
    DeepCopyAssignment obj1(5);
    DeepCopyAssignment obj2(3);
    
    std::cout << "\n初始状态：" << std::endl;
    obj1.display();  // 1 2 3 4 5
    obj2.display();  // 1 2 3
    
    obj2 = obj1;  // 调用深拷贝赋值运算符
    
    std::cout << "\n赋值后：" << std::endl;
    obj1.display();  // 1 2 3 4 5
    obj2.display();  // 1 2 3 4 5
    
    obj2.setValue(2, 100);
    
    std::cout << "\n修改obj2[2]=100后：" << std::endl;
    obj1.display();  // 1 2 3 4 5  ✓ 不受影响
    obj2.display();  // 1 2 100 4 5
    
    // 测试自赋值
    obj1 = obj1;  // 安全
    
    std::cout << "\n程序结束" << std::endl;
}
```

## 五、Rule of Three（三法则）

如果一个类需要以下任何一个，那么它通常需要全部三个：
1. 析构函数
2. 拷贝构造函数
3. 赋值运算符

```cpp
// Rule of Three 示例
class String {
private:
    char* data;
    int length;
    
public:
    // 1. 构造函数
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }
    
    // 2. 析构函数
    ~String() {
        delete[] data;
    }
    
    // 3. 拷贝构造函数
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
    }
    
    // 4. 赋值运算符
    String& operator=(const String& other) {
        // 自赋值检查
        if (this == &other) {
            return *this;
        }
        
        // 释放旧内存
        delete[] data;
        
        // 分配新内存并复制
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        
        return *this;
    }
    
    // 其他方法
    int getLength() const { return length; }
    const char* getData() const { return data; }
    
    // 拼接字符串
    String operator+(const String& other) const {
        String result;
        result.length = length + other.length;
        delete[] result.data;
        result.data = new char[result.length + 1];
        strcpy(result.data, data);
        strcat(result.data, other.data);
        return result;
    }
};
```

## 六、实际应用示例

###  **学生类（包含动态数组）**

```cpp
#include <iostream>
#include <cstring>

class Student {
private:
    char* name;
    int* scores;  // 动态数组
    int scoreCount;
    
public:
    // 构造函数
    Student(const char* n, const int* sc, int count) 
        : scoreCount(count) {
        // 分配并复制姓名
        name = new char[strlen(n) + 1];
        strcpy(name, n);
        
        // 分配并复制成绩
        scores = new int[scoreCount];
        for (int i = 0; i < scoreCount; i++) {
            scores[i] = sc[i];
        }
        
        std::cout << "构造: " << name << std::endl;
    }
    
    // 深拷贝构造函数
    Student(const Student& other) 
        : scoreCount(other.scoreCount) {
        // 复制姓名
        name = new char[strlen(other.name) + 1];
        strcpy(name, other.name);
        
        // 复制成绩
        scores = new int[scoreCount];
        for (int i = 0; i < scoreCount; i++) {
            scores[i] = other.scores[i];
        }
        
        std::cout << "拷贝构造: " << name << std::endl;
    }
    
    // 深拷贝赋值运算符
    Student& operator=(const Student& other) {
        std::cout << "赋值: " << name << " = " << other.name << std::endl;
        
        if (this == &other) {
            return *this;
        }
        
        // 释放原有资源
        delete[] name;
        delete[] scores;
        
        // 复制新数据
        scoreCount = other.scoreCount;
        
        name = new char[strlen(other.name) + 1];
        strcpy(name, other.name);
        
        scores = new int[scoreCount];
        for (int i = 0; i < scoreCount; i++) {
            scores[i] = other.scores[i];
        }
        
        return *this;
    }
    
    // 析构函数
    ~Student() {
        std::cout << "析构: " << name << std::endl;
        delete[] name;
        delete[] scores;
    }
    
    // 显示信息
    void display() const {
        std::cout << "学生: " << name << ", 成绩: ";
        for (int i = 0; i < scoreCount; i++) {
            std::cout << scores[i] << " ";
        }
        std::cout << ", 平均分: " << getAverage() << std::endl;
    }
    
    // 计算平均分
    double getAverage() const {
        if (scoreCount == 0) return 0.0;
        int sum = 0;
        for (int i = 0; i < scoreCount; i++) {
            sum += scores[i];
        }
        return static_cast<double>(sum) / scoreCount;
    }
    
    // 修改姓名
    void setName(const char* newName) {
        delete[] name;
        name = new char[strlen(newName) + 1];
        strcpy(name, newName);
    }
    
    // 修改成绩
    void setScore(int index, int score) {
        if (index >= 0 && index < scoreCount) {
            scores[index] = score;
        }
    }
};
```

## 七、现代C++解决方案

### 1. **使用智能指针（推荐！）**

```cpp
#include <memory>
#include <vector>
#include <string>

class SmartStudent {
private:
    std::unique_ptr<char[]> name;  // 智能指针管理内存
    std::vector<int> scores;       // vector自动管理内存
    
public:
    // 构造函数
    SmartStudent(const char* n, std::initializer_list<int> sc) 
        : scores(sc) {
        name = std::make_unique<char[]>(strlen(n) + 1);
        strcpy(name.get(), n);
        
        std::cout << "构造: " << name.get() << std::endl;
    }
    
    // 不需要写析构函数、拷贝构造函数、赋值运算符！
    // 智能指针和vector会自动处理深拷贝
    
    // 默认的拷贝构造函数和赋值运算符就能工作
    // 因为unique_ptr不能被拷贝，但vector可以
    
    // 如果需要拷贝，可以这样写：
    SmartStudent(const SmartStudent& other) 
        : scores(other.scores) {
        name = std::make_unique<char[]>(strlen(other.name.get()) + 1);
        strcpy(name.get(), other.name.get());
    }
    
    SmartStudent& operator=(const SmartStudent& other) {
        if (this == &other) return *this;
        
        name = std::make_unique<char[]>(strlen(other.name.get()) + 1);
        strcpy(name.get(), other.name.get());
        
        scores = other.scores;
        
        return *this;
    }
    
    // 显示信息
    void display() const {
        std::cout << "学生: " << name.get() << ", 成绩: ";
        for (int score : scores) {
            std::cout << score << " ";
        }
        std::cout << std::endl;
    }
};
```

### 2. **使用标准库容器**

```cpp
#include <string>
#include <vector>
#include <iostream>

class ModernBook {
private:
    std::string title;      // string自动管理内存
    std::string author;     // string自动管理内存
    std::vector<int> borrowers;  // vector自动管理内存
    
public:
    // 构造函数
    ModernBook(const std::string& t, const std::string& a) 
        : title(t), author(a) {}
    
    // 不需要写析构函数、拷贝构造函数、赋值运算符！
    // string和vector会自动处理深拷贝
    
    // 借书
    void borrow(int userId) {
        borrowers.push_back(userId);
    }
    
    // 还书
    bool returnBook(int userId) {
        for (auto it = borrowers.begin(); it != borrowers.end(); ++it) {
            if (*it == userId) {
                borrowers.erase(it);
                return true;
            }
        }
        return false;
    }
    
    // 显示信息
    void display() const {
        std::cout << "《" << title << "》作者: " << author 
                  << ", 借阅次数: " << borrowers.size() << std::endl;
    }
    
    // Getter
    std::string getTitle() const { return title; }
    std::string getAuthor() const { return author; }
    
    // Setter
    void setTitle(const std::string& t) { title = t; }
    void setAuthor(const std::string& a) { author = a; }
};
```

## 八、何时需要深拷贝？

### 1. **需要深拷贝的情况**

```cpp
// 情况1：类包含动态分配的内存
class NeedsDeepCopy1 {
    int* data;  // 需要深拷贝
    // ... 实现深拷贝构造函数和赋值运算符
};

// 情况2：类包含需要深拷贝的成员
class NeedsDeepCopy2 {
    char* buffer;  // 需要深拷贝
    FILE* file;    // 需要特殊处理
    // ... 实现深拷贝构造函数和赋值运算符
};
```

### 2. **不需要深拷贝的情况**

```cpp
// 情况1：只包含基本类型
class NoNeedDeepCopy1 {
    int x, y;     // 基本类型，默认拷贝即可
    double value; // 基本类型
    // 不需要写深拷贝
};

// 情况2：使用智能指针或标准库
class NoNeedDeepCopy2 {
    std::string name;      // string自动深拷贝
    std::vector<int> data; // vector自动深拷贝
    std::shared_ptr<int> ptr; // 智能指针
    // 不需要写深拷贝
};

// 情况3：禁止拷贝的类
class NonCopyable {
private:
    int* resource;
    
    // 删除拷贝构造函数和赋值运算符
    NonCopyable(const NonCopyable&) = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
    
public:
    NonCopyable() : resource(new int(42)) {}
    
    ~NonCopyable() {
        delete resource;
    }
    
    // 只能移动，不能拷贝
    NonCopyable(NonCopyable&& other) noexcept 
        : resource(other.resource) {
        other.resource = nullptr;
    }
    
    NonCopyable& operator=(NonCopyable&& other) noexcept {
        if (this != &other) {
            delete resource;
            resource = other.resource;
            other.resource = nullptr;
        }
        return *this;
    }
};
```

## 九、常见错误和解决方案

### 1. **常见错误**

```cpp
class CommonMistakes {
private:
    char* data;
    
public:
    CommonMistakes(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }
    
    // 错误1：忘记写析构函数
    // ~CommonMistakes() { delete[] data; }
    
    // 错误2：浅拷贝构造函数
    CommonMistakes(const CommonMistakes& other) 
        : data(other.data) {  // 浅拷贝！
    }
    
    // 错误3：浅拷贝赋值运算符
    CommonMistakes& operator=(const CommonMistakes& other) {
        data = other.data;  // 浅拷贝！内存泄漏！
        return *this;
    }
    
    // 错误4：忘记自赋值检查
    CommonMistakes& badAssignment(const CommonMistakes& other) {
        delete[] data;  // 如果自赋值，这里就释放了自己的数据！
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        return *this;
    }
};
```

### 2. **正确写法模板**

```cpp
class CorrectImplementation {
private:
    Type1* resource1;  // 需要深拷贝的资源
    Type2* resource2;
    
public:
    // 构造函数
    CorrectImplementation(...) {
        // 分配资源
    }
    
    // 深拷贝构造函数
    CorrectImplementation(const CorrectImplementation& other) {
        // 1. 复制基本类型
        // 2. 为指针分配新内存
        // 3. 复制指针指向的数据
    }
    
    // 深拷贝赋值运算符
    CorrectImplementation& operator=(const CorrectImplementation& other) {
        // 1. 检查自赋值
        if (this == &other) {
            return *this;
        }
        
        // 2. 释放原有资源
        delete resource1;
        delete resource2;
        
        // 3. 分配新资源
        // 4. 复制数据
        
        return *this;
    }
    
    // 析构函数
    ~CorrectImplementation() {
        delete resource1;
        delete resource2;
    }
};
```

## 总结

### **关键点**：
1. **浅拷贝**：只复制指针，不复制数据 → 多个对象共享同一数据
2. **深拷贝**：复制指针和数据 → 每个对象有自己的独立数据
3. **默认拷贝**：C++默认是浅拷贝
4. **Rule of Three**：如果需要析构函数，通常也需要拷贝构造函数和赋值运算符

### **何时需要深拷贝**：
- 类包含动态分配的内存（new/malloc）
- 类包含需要深拷贝的资源（文件句柄、网络连接等）

### **何时不需要深拷贝**：
- 只包含基本类型
- 使用智能指针和标准库容器
- 明确禁止拷贝的类

### **最佳实践**：
1. 优先使用智能指针（`std::unique_ptr`, `std::shared_ptr`）
2. 优先使用标准库容器（`std::string`, `std::vector`）
3. 遵循Rule of Three（或Rule of Five）
4. 记得检查自赋值
5. 使用移动语义提高性能（C++11+）

### **记忆口诀**：
```
深浅拷贝要分清，指针复制是浅拷
数据也要复制来，独立内存是深拷
默认拷贝是浅的，动态内存要小心
三法则要记住，析构拷贝赋值全
现代C++用智能，标准容器更方便
```