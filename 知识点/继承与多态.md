
# 继承与多态（Inheritance & Polymorphism）


## ✅ 1. **继承（Inheritance）**

继承是 OOP 的一大特性，允许你创建一个类（**子类**），从另一个已有的类（**父类**）继承属性和行为。它帮助我们实现代码的**复用**。

### 示例：继承 `Person` 类

```cpp
class Person {
public:
    string name;
    int age;

    Person(string n, int a) : name(n), age(a) {}

    void show() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

class Student : public Person {
public:
    int grade;

    Student(string n, int a, int g) : Person(n, a), grade(g) {}

    void show() {
        // 调用父类的 show() 函数
        Person::show();
        cout << "Grade: " << grade << endl;
    }
};
```

### 解析：

* **父类**：`Person`。
* **子类**：`Student`。
* **`Student` 继承了 `Person` 的属性和方法**，并且可以扩展新的功能（如 `grade` 和 `show`）。

---

## ✅ 2. **继承的访问控制：public, protected, private**

继承时，父类的成员可以有不同的访问控制级别。默认情况下：

* **public** 继承：父类的 `public` 和 `protected` 成员保持其访问权限。
* **protected** 继承：父类的 `public` 和 `protected` 成员会变为 `protected`。
* **private** 继承：父类的 `public` 和 `protected` 成员会变为 `private`。

### 示例：不同的继承类型

```cpp
class Person {
public:
    string name;
    int age;
    
    Person(string n, int a) : name(n), age(a) {}
    void show() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

class Student : public Person {  // public 继承
public:
    int grade;
    
    Student(string n, int a, int g) : Person(n, a), grade(g) {}
    
    void show() {
        Person::show();
        cout << "Grade: " << grade << endl;
    }
};
```

---

## ✅ 3. **构造函数与继承**

* **父类的构造函数**：子类在构造时必须调用父类的构造函数来初始化继承来的成员。
* **子类的构造函数**：子类可以扩展新的成员，但要使用初始化列表调用父类的构造函数。

### 示例：继承与构造函数

```cpp
class Person {
public:
    string name;
    int age;

    Person(string n, int a) : name(n), age(a) {}

    void show() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

class Employee : public Person {
public:
    string company;

    Employee(string n, int a, string c) : Person(n, a), company(c) {}

    void show() {
        Person::show();
        cout << "Company: " << company << endl;
    }
};
```

---

## ✅ 4. **多态（Polymorphism）**

多态是面向对象编程中最强大的特性之一。它允许我们在不同的类层次结构中使用相同的接口，能够动态地决定调用哪个方法。

* **静态多态**：函数重载、运算符重载。
* **动态多态**：通过虚函数实现，能够在运行时确定调用哪个函数。

### 4.1 **虚函数（Virtual Functions）**

虚函数是用 `virtual` 关键字声明的成员函数。通过虚函数，**基类指针或引用**可以调用派生类的函数，达到运行时决定调用哪个版本的函数。

### 示例：虚函数与多态

```cpp
class Animal {
public:
    virtual void speak() {
        cout << "Animal speaks" << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {
        cout << "Dog barks" << endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        cout << "Cat meows" << endl;
    }
};
```

### 解析：

* **`Animal` 类**中有一个虚函数 `speak`，子类 `Dog` 和 `Cat` 重写了这个函数。
* 当使用 `Animal` 类型的指针调用 `speak` 时，程序会根据指向对象的实际类型决定调用哪个版本的函数。

```cpp
int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();

    animal1->speak();  // 输出：Dog barks
    animal2->speak();  // 输出：Cat meows

    delete animal1;
    delete animal2;

    return 0;
}
```

---

## ✅ 5. **纯虚函数与抽象类**

如果一个类包含纯虚函数（没有实现的函数），那么这个类就被称为**抽象类**，无法实例化。

### 示例：纯虚函数与抽象类

```cpp
class Shape {
public:
    virtual void draw() = 0;  // 纯虚函数
    virtual double area() = 0;  // 纯虚函数
};

class Circle : public Shape {
public:
    double radius;

    Circle(double r) : radius(r) {}

    void draw() override {
        cout << "Drawing a circle" << endl;
    }

    double area() override {
        return 3.14159 * radius * radius;
    }
};
```

### 解析：

* `Shape` 是一个抽象类，包含了两个纯虚函数 `draw` 和 `area`。
* `Circle` 实现了这些纯虚函数，因此它是一个具体类，可以实例化。

---


