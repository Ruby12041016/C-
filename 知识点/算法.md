
# 算法

## 1.1 算法库（Algorithm）详解

算法库包含100多个函数，讲解：

### 1.1.1 不修改序列的算法

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>  // 数值算法

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5, 3, 2, 1};
    
    // 1. 查找算法
    // find - 查找特定值
    auto it = std::find(v.begin(), v.end(), 3);
    if (it != v.end()) {
        std::cout << "找到3，位置：" << it - v.begin() << std::endl;
    }
    
    // find_if - 按条件查找
    auto it2 = std::find_if(v.begin(), v.end(), 
        int x { return x > 4; });  // 查找第一个大于4的
    if (it2 != v.end()) {
        std::cout << "第一个大于4的是：" << *it2 << std::endl;
    }
    
    // count - 计数
    int cnt = std::count(v.begin(), v.end(), 2);
    std::cout << "2出现了" << cnt << "次" << std::endl;
    
    // count_if - 条件计数
    int cnt2 = std::count_if(v.begin(), v.end(),
        int x { return x % 2 == 0; });  // 偶数个数
    std::cout << "偶数有" << cnt2 << "个" << std::endl;
    
    // 2. 查找极值
    auto min_it = std::min_element(v.begin(), v.end());
    auto max_it = std::max_element(v.begin(), v.end());
    std::cout << "最小值：" << *min_it 
              << "，最大值：" << *max_it << std::endl;
    
    // 3. 数值算法（在<numeric>中）
    int sum = std::accumulate(v.begin(), v.end(), 0);  // 求和
    std::cout << "总和：" << sum << std::endl;
    
    // 计算乘积
    int product = std::accumulate(v.begin(), v.end(), 1,
        int a, int b { return a * b; });
    std::cout << "乘积：" << product << std::endl;
    
    // 内积（点积）
    std::vector<int> a = {1, 2, 3};
    std::vector<int> b = {4, 5, 6};
    int dot_product = std::inner_product(a.begin(), a.end(), b.begin(), 0);
    std::cout << "内积：" << dot_product << std::endl;  // 1*4 + 2*5 + 3*6 = 32
    
    return 0;
}
```

### 1.1.2 修改序列的算法

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>  // 迭代器辅助函数

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    
    // 1. 复制
    std::vector<int> v2(v.size());
    std::copy(v.begin(), v.end(), v2.begin());
    
    // 复制到输出流
    std::copy(v.begin(), v.end(), 
        std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;
    
    // 2. 填充
    std::vector<int> v3(5);
    std::fill(v3.begin(), v3.end(), 42);  // 全部填充为42
    // v3: {42, 42, 42, 42, 42}
    
    // 3. 生成
    std::vector<int> v4(5);
    int counter = 0;
    std::generate(v4.begin(), v4.end(), 
         { return counter++; });  // 生成0,1,2,3,4
    
    // 4. 变换（map操作）
    std::vector<int> v5 = {1, 2, 3, 4, 5};
    std::vector<int> v6(v5.size());
    
    // 每个元素平方
    std::transform(v5.begin(), v5.end(), v6.begin(),
        int x { return x * x; });  // {1, 4, 9, 16, 25}
    
    // 5. 替换
    std::vector<int> v7 = {1, 2, 3, 2, 1};
    std::replace(v7.begin(), v7.end(), 2, 99);  // 所有2替换为99
    // v7: {1, 99, 3, 99, 1}
    
    // 条件替换
    std::replace_if(v7.begin(), v7.end(),
        int x { return x > 50; }, 0);  // 大于50的替换为0
    // v7: {1, 0, 3, 0, 1}
    
    return 0;
}
```

### 1.1.3 排序和相关算法

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v = {5, 2, 8, 1, 9, 3, 5, 2};
    
    // 1. 排序
    std::sort(v.begin(), v.end());  // 默认升序
    // v: {1, 2, 2, 3, 5, 5, 8, 9}
    
    // 降序排序
    std::sort(v.begin(), v.end(), std::greater<int>());
    // v: {9, 8, 5, 5, 3, 2, 2, 1}
    
    // 自定义排序规则
    std::vector<std::string> words = {"apple", "banana", "cherry", "date"};
    std::sort(words.begin(), words.end(),
        const std::string& a, const std::string& b {
            return a.length() < b.length();  // 按长度排序
        });
    // 结果: date, apple, banana, cherry (按长度递增)
    
    // 2. 部分排序
    std::vector<int> v2 = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    std::partial_sort(v2.begin(), v2.begin() + 3, v2.end());
    // 只保证前3个是最小的且有序
    // v2前3个: {1, 2, 3}，后面无序
    
    // 3. 第n个元素
    std::vector<int> v3 = {5, 2, 8, 1, 9, 3};
    auto mid = v3.begin() + v3.size() / 2;
    std::nth_element(v3.begin(), mid, v3.end());
    std::cout << "中位数: " << *mid << std::endl;  // 中间位置的值
    
    // 4. 二分查找（必须在有序序列上使用！）
    std::vector<int> sorted = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    bool found = std::binary_search(sorted.begin(), sorted.end(), 5);
    std::cout << "5是否存在: " << std::boolalpha << found << std::endl;
    
    // 查找边界
    auto lower = std::lower_bound(sorted.begin(), sorted.end(), 5);
    // 第一个不小于5的位置
    auto upper = std::upper_bound(sorted.begin(), sorted.end(), 5);
    // 第一个大于5的位置
    std::cout << "5的范围: [" << (lower - sorted.begin()) 
              << ", " << (upper - sorted.begin()) << ")" << std::endl;
    
    // 5. 合并两个有序序列
    std::vector<int> a = {1, 3, 5, 7};
    std::vector<int> b = {2, 4, 6, 8};
    std::vector<int> merged(a.size() + b.size());
    
    std::merge(a.begin(), a.end(), b.begin(), b.end(), merged.begin());
    // merged: {1, 2, 3, 4, 5, 6, 7, 8}
    
    return 0;
}
```

### 1.1.4 分区和划分算法

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v = {1, 8, 3, 6, 5, 2, 7, 4};
    
    // 1. 分区：把满足条件的放到前面
    auto it = std::partition(v.begin(), v.end(),
        int x { return x % 2 == 0; });  // 偶数在前
    
    std::cout << "分区后: ";
    for (int num : v) std::cout << num << " ";
    std::cout << "\n分界点: " << *it << std::endl;
    
    // 2. stable_partition：保持原有顺序
    std::vector<int> v2 = {1, 8, 3, 6, 5, 2, 7, 4};
    auto it2 = std::stable_partition(v2.begin(), v2.end(),
        int x { return x % 2 == 0; });
    
    // 检查是否是分区点
    bool is_partitioned = std::is_partitioned(v.begin(), v.end(),
        int x { return x % 2 == 0; });
    std::cout << "是否已分区: " << is_partitioned << std::endl;
    
    return 0;
}
```

### 1.1.5 集合算法（操作已排序的序列）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> A = {1, 2, 3, 4, 5};
    std::vector<int> B = {3, 4, 5, 6, 7};
    std::vector<int> result;
    
    // 1. 并集（合并，去重）
    result.clear();
    std::set_union(A.begin(), A.end(), B.begin(), B.end(),
        std::back_inserter(result));
    // result: {1, 2, 3, 4, 5, 6, 7}
    
    // 2. 交集
    result.clear();
    std::set_intersection(A.begin(), A.end(), B.begin(), B.end(),
        std::back_inserter(result));
    // result: {3, 4, 5}
    
    // 3. 差集 (A - B)
    result.clear();
    std::set_difference(A.begin(), A.end(), B.begin(), B.end(),
        std::back_inserter(result));
    // result: {1, 2}
    
    // 4. 对称差集 (A ∪ B - A ∩ B)
    result.clear();
    std::set_symmetric_difference(A.begin(), A.end(), B.begin(), B.end(),
        std::back_inserter(result));
    // result: {1, 2, 6, 7}
    
    // 5. 判断包含关系
    bool includes = std::includes(A.begin(), A.end(), 
        std::vector<int>{2, 3}.begin(), std::vector<int>{2, 3}.end());
    std::cout << "A包含{2,3}吗? " << includes << std::endl;
    
    return 0;
}
```







