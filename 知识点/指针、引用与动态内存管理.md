# 指针、引用与动态内存管理 

## 引用

### 1. 引用的概念

**引用是变量的别名：**
```cpp
#include <iostream>
using namespace std;

int main() {
    int num = 100;
    int& ref = num;  // ref是num的引用（别名）
    
    cout << "num = " << num << endl;   // 100
    cout << "ref = " << ref << endl;   // 100
    
    ref = 200;  // 通过引用修改变量
    
    cout << "修改后 num = " << num << endl;  // 200
    cout << "修改后 ref = " << ref << endl;  // 200
    
    // 验证它们是同一个东西
    cout << "num的地址: " << &num << endl;
    cout << "ref的地址: " << &ref << endl;  // 相同地址！
    
    return 0;
}
```

**引用的特性：**
1. 必须初始化
2. 不能改变绑定的对象
3. 没有空引用
4. 没有引用数组

```cpp
int x = 10;
int& ref1 = x;  // ✓ 正确
int& ref2;      // ✗ 错误：必须初始化

int y = 20;
ref1 = y;       // 这是赋值，不是重新绑定！
cout << x << endl;  // 20，x的值被改变了
```

### 2. 指针 vs 引用

| 特性 | 指针 | 引用 |
|------|------|------|
| 声明 | `int* p;` | `int& r = x;` |
| 初始化 | 可以稍后初始化 | 必须声明时初始化 |
| 可否为空 | 可以（nullptr） | 不可以 |
| 可否重新绑定 | 可以 | 不可以 |
| 内存占用 | 占用内存存储地址 | 不占用额外内存（编译器优化） |
| 操作符 | `*` 解引用，`->` 成员访问 | 像普通变量一样使用 |
| 安全性 | 较低（可能为空，野指针） | 较高（必须绑定有效对象） |

**使用场景：**
- 指针：需要动态内存分配，需要重新指向不同对象
- 引用：函数参数传递，避免拷贝，运算符重载

### 3. 指针的指针（二级指针）

```cpp
int value = 100;
int* ptr = &value;     // 一级指针
int** pptr = &ptr;     // 二级指针（指向指针的指针）

cout << "value = " << value << endl;        // 100
cout << "*ptr = " << *ptr << endl;          // 100
cout << "**pptr = " << **pptr << endl;      // 100

cout << "&value = " << &value << endl;      // 地址1
cout << "ptr = " << ptr << endl;            // 地址1
cout << "*pptr = " << *pptr << endl;        // 地址1

cout << "&ptr = " << &ptr << endl;          // 地址2
cout << "pptr = " << pptr << endl;          // 地址2
```

**指针的指针应用：**
```cpp
// 动态二维数组
int rows = 3, cols = 4;
int** matrix = new int*[rows];  // 创建指针数组
for (int i = 0; i < rows; i++) {
    matrix[i] = new int[cols];  // 为每一行分配空间
}

// 使用...
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = i * 10 + j;
    }
}

// 释放内存
for (int i = 0; i < rows; i++) {
    delete[] matrix[i];
}
delete[] matrix;
```

## 动态内存管理

### 1. 栈内存 vs 堆内存

| 特性 | 栈内存 (Stack) | 堆内存 (Heap) |
|------|---------------|--------------|
| 分配方式 | 自动分配/释放 | 手动分配/释放 |
| 大小 | 较小（通常几MB） | 较大（可达GB） |
| 速度 | 快 | 慢 |
| 管理 | 编译器管理 | 程序员管理 |
| 生命周期 | 作用域内 | 直到被释放 |
| 示例 | 局部变量 | new创建的对象 |

### 2. new 和 delete 操作符

```cpp
#include <iostream>
using namespace std;

int main() {
    // 1. 动态分配单个变量
    int* pInt = new int;       // 分配一个int
    *pInt = 100;               // 赋值
    cout << *pInt << endl;     // 100
    delete pInt;               // 释放内存
    
    // 2. 动态分配并初始化
    int* pInt2 = new int(200); // 分配并初始化为200
    cout << *pInt2 << endl;    // 200
    delete pInt2;
    
    // 3. 动态分配数组
    int size = 5;
    int* arr = new int[size];  // 动态数组
    
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10;       // 初始化
    }
    
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";  // 0 10 20 30 40
    }
    cout << endl;
    
    delete[] arr;  // 注意：数组用delete[]
    
    // 4. 动态分配并初始化数组
    int* arr2 = new int[5]{1, 2, 3, 4, 5};  // C++11
    delete[] arr2;
    
    return 0;
}
```

## 指针和函数

### 1. 指针作为函数参数

```cpp
#include <iostream>
using namespace std;

// 值传递（创建副本）
void swapByValue(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    // 只交换了副本
}

// 指针传递（传递地址）
void swapByPointer(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
    // 交换了实际变量
}

// 引用传递（传递别名）
void swapByReference(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
    // 交换了实际变量
}

int main() {
    int x = 10, y = 20;
    
    cout << "交换前: x=" << x << ", y=" << y << endl;
    
    swapByValue(x, y);
    cout << "值传递后: x=" << x << ", y=" << y << endl;  // 没变
    
    swapByPointer(&x, &y);
    cout << "指针传递后: x=" << x << ", y=" << y << endl;  // 交换了
    
    swapByReference(x, y);
    cout << "引用传递后: x=" << x << ", y=" << y << endl;  // 又交换回来了
    
    return 0;
}
```

### 2. 返回指针的函数

```cpp
#include <iostream>
using namespace std;

// 危险：返回局部变量的地址
int* badFunction() {
    int localVar = 100;
    return &localVar;  // 错误：函数结束局部变量被销毁
}

// 正确：返回动态分配的内存
int* createArray(int size) {
    int* arr = new int[size];
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10;
    }
    return arr;  // 调用者需要负责delete[]
}

// 正确：返回静态变量的地址
int* getStaticValue() {
    static int staticVar = 999;  // 静态变量，程序结束才销毁
    return &staticVar;
}

int main() {
    int* arr = createArray(5);
    
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";  // 0 10 20 30 40
    }
    cout << endl;
    
    delete[] arr;  // 重要：释放内存
    
    return 0;
}
```

### 3. 函数指针

```cpp
#include <iostream>
using namespace std;

// 普通函数
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // 函数指针声明
    int (*funcPtr)(int, int);
    
    // 指向add函数
    funcPtr = add;
    cout << "add(5, 3) = " << funcPtr(5, 3) << endl;  // 8
    
    // 指向multiply函数
    funcPtr = multiply;
    cout << "multiply(5, 3) = " << funcPtr(5, 3) << endl;  // 15
    
    // 函数指针数组
    int (*funcArray[])(int, int) = {add, multiply};
    
    cout << "funcArray5, 3 = " << funcArray5, 3 << endl;  // 8
    cout << "funcArray5, 3 = " << funcArray5, 3 << endl;  // 15
    
    return 0;
}
```

### 4. 回调函数

#### 什么是回调函数？

回调函数是一种通过函数指针调用的函数。简单来说，就是将函数作为参数传递给另一个函数，并在适当的时候被调用。

## 1. 基本概念

```cpp
#include <iostream>
using namespace std;

// 1.1 函数指针定义回调
typedef void (*Callback)(int);

// 回调函数示例
void printNumber(int num) {
    cout << "回调函数被调用，数字是: " << num << endl;
}

// 接受回调的函数
void processNumber(int num, Callback callback) {
    cout << "处理数字: " << num << endl;
    callback(num * 2);  // 调用回调函数
}

int main() {
    processNumber(5, printNumber);
    return 0;
}
```

## 2. 实际应用示例

### 2.1 事件处理
```cpp
#include <iostream>
#include <vector>
#include <functional>
using namespace std;

// 事件处理器类
class EventHandler {
private:
    vector<function<void(int)>> listeners;
    
public:
    // 注册回调函数
    void addListener(function<void(int)> callback) {
        listeners.push_back(callback);
    }
    
    // 触发事件
    void fireEvent(int data) {
        cout << "事件触发，数据: " << data << endl;
        for (auto& listener : listeners) {
            listener(data);
        }
    }
};

// 具体的事件处理器
void logHandler(int data) {
    cout << "[日志] 收到数据: " << data << endl;
}

void alertHandler(int data) {
    if (data > 100) {
        cout << "[警告] 数据超过阈值: " << data << endl;
    }
}

int main() {
    EventHandler handler;
    
    // 注册回调函数
    handler.addListener(logHandler);
    handler.addListener(alertHandler);
    
    // 触发事件
    handler.fireEvent(50);
    handler.fireEvent(150);
    
    return 0;
}
```

