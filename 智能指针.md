# 智能指针详解

## 一、什么是智能指针

智能指针是C++中用于管理动态内存的类模板，它们通过RAII（Resource Acquisition Is Initialization）技术来自动管理内存，避免内存泄漏。

## 二、标准库智能指针类型

### 1. **std::unique_ptr**（独占指针）

**特点**：
- 独占所有权，不能拷贝，只能移动
- 管理单个对象或数组
- 性能接近原始指针

```cpp
#include <memory>
#include <iostream>

// 管理单个对象
void unique_ptr_example() {
    // 创建unique_ptr
    std::unique_ptr<int> p1(new int(10));
    
    // 使用make_unique（C++14起推荐）
    auto p2 = std::make_unique<int>(20);
    
    // 转移所有权（只能移动，不能拷贝）
    std::unique_ptr<int> p3 = std::move(p2);
    
    // 访问指针
    std::cout << *p1 << std::endl;  // 10
    std::cout << *p3 << std::endl;  // 20
    // std::cout << *p2 << std::endl;  // 错误！p2已为空
    
    // 管理数组
    auto arr = std::make_unique<int[]>(5);
    arr[0] = 100;
    
    // 自定义删除器
    auto deleter = int* p {
        std::cout << "Deleting int pointer" << std::endl;
        delete p;
    };
    std::unique_ptr<int, decltype(deleter)> p4(new int(30), deleter);
}
```

### 2. **std::shared_ptr**（共享指针）

**特点**：
- 共享所有权，使用引用计数
- 多个shared_ptr可以指向同一对象
- 当最后一个shared_ptr销毁时释放内存

```cpp
void shared_ptr_example() {
    // 创建shared_ptr
    std::shared_ptr<int> sp1(new int(10));
    
    // 使用make_shared（推荐，内存分配更高效）
    auto sp2 = std::make_shared<int>(20);
    
    // 共享所有权
    auto sp3 = sp2;  // 引用计数+1
    
    std::cout << "sp2 use_count: " << sp2.use_count() << std::endl;  // 2
    std::cout << "sp3 use_count: " << sp3.use_count() << std::endl;  // 2
    
    // 自定义删除器
    std::shared_ptr<int> sp4(new int[5], std::default_delete<int[]>());
    
    // weak_ptr配合使用（解决循环引用）
    std::weak_ptr<int> wp = sp2;
    if (auto spt = wp.lock()) {  // 转换为shared_ptr
        std::cout << *spt << std::endl;  // 20
    }
}
```

### 3. **std::weak_ptr**（弱指针）

**特点**：
- 不增加引用计数
- 解决shared_ptr循环引用问题
- 必须转换为shared_ptr才能访问对象

```cpp
class Node {
public:
    std::string name;
    std::shared_ptr<Node> parent;
    std::weak_ptr<Node> child;  // 使用weak_ptr避免循环引用
    
    Node(const std::string& n) : name(n) {
        std::cout << "Node " << name << " created" << std::endl;
    }
    
    ~Node() {
        std::cout << "Node " << name << " destroyed" << std::endl;
    }
};

void weak_ptr_example() {
    auto parent = std::make_shared<Node>("Parent");
    auto child = std::make_shared<Node>("Child");
    
    parent->child = child;  // weak_ptr不会增加引用计数
    child->parent = parent;  // shared_ptr会增加引用计数
    
    // 使用weak_ptr
    if (auto child_ptr = parent->child.lock()) {
        std::cout << "Child exists: " << child_ptr->name << std::endl;
    }
}
```

### 4. **std::auto_ptr**（已废弃）

**注意**：C++11中已废弃，C++17中已移除，不应再使用。

## 三、核心特性对比

| 特性 | unique_ptr | shared_ptr | weak_ptr |
|------|------------|------------|----------|
| 所有权 | 独占 | 共享 | 无所有权 |
| 拷贝 | 不允许 | 允许 | 允许 |
| 移动 | 允许 | 允许 | 允许 |
| 引用计数 | 无 | 有 | 观察引用计数 |
| 性能开销 | 很小 | 较大（引用计数） | 中等 |
| 适用场景 | 独占资源管理 | 共享资源管理 | 打破循环引用 |

## 四、智能指针的高级用法

### 1. **自定义删除器**

```cpp
struct FileDeleter {
    void operator()(FILE* fp) const {
        if (fp) {
            std::cout << "Closing file" << std::endl;
            fclose(fp);
        }
    }
};

void custom_deleter_example() {
    // unique_ptr自定义删除器
    std::unique_ptr<FILE, FileDeleter> filePtr(fopen("test.txt", "w"));
    
    // shared_ptr自定义删除器
    std::shared_ptr<FILE> sharedFile(fopen("test.txt", "r"),
        FILE* fp {
            if (fp) fclose(fp);
        });
}
```

### 2. **管理动态数组**

```cpp
void array_management() {
    // C++11/14方式
    std::unique_ptr<int[]> arr1(new int[10]);
    arr1[0] = 1;
    
    // C++17推荐方式
    auto arr2 = std::make_unique<int[]>(10);
    arr2[0] = 2;
    
    // shared_ptr管理数组（需要自定义删除器）
    std::shared_ptr<int> arr3(new int[10], std::default_delete<int[]>());
    // 或使用C++17的shared_ptr<T[]>
    std::shared_ptr<int[]> arr4(new int[10]);
}
```

### 3. **作为函数参数和返回值**

```cpp
// 参数传递规则
void process_unique(std::unique_ptr<int> ptr) {
    // 获取所有权
    std::cout << *ptr << std::endl;
}  // ptr自动释放

void process_shared(const std::shared_ptr<int>& ptr) {
    // 不获取所有权，只使用
    std::cout << *ptr << std::endl;
}

std::unique_ptr<int> create_unique() {
    return std::make_unique<int>(42);
}

std::shared_ptr<int> create_shared() {
    return std::make_shared<int>(42);
}
```

### 4. **性能考虑**

```cpp
void performance_considerations() {
    // make_shared vs new + shared_ptr
    // make_shared：单次内存分配（对象+控制块）
    auto sp1 = std::make_shared<int>(10);
    
    // new + shared_ptr：两次内存分配
    std::shared_ptr<int> sp2(new int(20));
    
    // unique_ptr性能接近原始指针
    auto up = std::make_unique<int>(30);
}
```
## 五、常见错误

### 1. **智能指针常见错误**

```cpp
void common_mistakes_smart_pointers() {
    // 错误1：混合使用智能指针和裸指针
    int* raw_ptr = new int(42);
    std::shared_ptr<int> sp1(raw_ptr);
    // std::shared_ptr<int> sp2(raw_ptr);  // 错误！双重释放
    
    // 正确做法
    auto sp1_ok = std::make_shared<int>(42);
    auto sp2_ok = sp1_ok;  // 安全共享
    
    // 错误2：循环引用
    class Node {
    public:
        std::shared_ptr<Node> next;  // 应该用weak_ptr
    };
    
    auto node1 = std::make_shared<Node>();
    auto node2 = std::make_shared<Node>();
    node1->next = node2;
    node2->next = node1;  // 循环引用！内存泄漏
    
    // 错误3：get()返回的指针管理不当
    auto sp = std::make_shared<int>(100);
    int* ptr = sp.get();
    // delete ptr;  // 绝对不能delete！
    // 忘记ptr存在，再次使用sp
    
    // 错误4：unique_ptr错误拷贝
    auto up1 = std::make_unique<int>(200);
    // auto up2 = up1;  // 错误！不能拷贝
    auto up2 = std::move(up1);  // 正确：转移所有权
}
```
## 六、使用建议

1. **优先使用智能指针，避免裸指针**
2. **按需选择智能指针类型**：
   - 独占所有权 → `unique_ptr`
   - 共享所有权 → `shared_ptr`
   - 观察者 → `weak_ptr`
3. **使用make_shared/make_unique**（C++14+）
4. **注意循环引用问题**，使用weak_ptr解决
5. **避免混合使用智能指针和裸指针**
6. **多线程环境下注意线程安全**（shared_ptr引用计数操作是原子的）

## 七、实战示例

```cpp
class Resource {
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource released\n"; }
    void use() { std::cout << "Resource in use\n"; }
};

void practical_example() {
    // 1. 工厂函数返回unique_ptr
    auto createResource =  -> std::unique_ptr<Resource> {
        return std::make_unique<Resource>();
    };
    
    // 2. 资源管理
    auto res1 = createResource();
    res1->use();
    
    // 3. 转移资源所有权
    auto res2 = std::move(res1);
    
    // 4. 共享资源
    std::shared_ptr<Resource> sharedRes = std::move(res2);
    auto sharedRes2 = sharedRes;
    
    // 5. 观察资源
    std::weak_ptr<Resource> weakRes = sharedRes;
    
    // 6. 资源自动释放
}  // 所有资源在此处自动释放
```

智能指针是现代C++内存管理的核心工具，正确使用可以显著提高代码的安全性和可维护性。