# C++容器核心知识点详解

## 容器学习路线图

**第一阶段：序列容器（线性排列）**
1. `vector` - 动态数组 ✅
2. `string` - 字符串（特殊vector）
3. `array` - 静态数组
4. `list`/`forward_list` - 链表
5. `deque` - 双端队列

**第二阶段：关联容器（按键查找）**
6. `map`/`set` - 红黑树（有序）
7. `unordered_map`/`unordered_set` - 哈希表（无序）

---

# 1. vector - 动态数组（最常用）

## 1.1 基本概念
想象一个可以**自动变长**的数组，元素在内存中**连续存储**。

```cpp
// 内存布局示意图
vector<int> v = {1, 2, 3, 4, 5};
内存地址: 0x1000 0x1004 0x1008 0x100C 0x1010
值:      [1]    [2]    [3]    [4]    [5]
         ↑      ↑      ↑      ↑      ↑
       连续存储，每个int占4字节
```

## 1.2 创建和初始化（6种方法）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 1. 默认构造 - 空vector
    vector<int> v1;
    
    // 2. 指定大小，默认值初始化
    vector<int> v2(5);           // 5个0: {0, 0, 0, 0, 0}
    vector<int> v3(5, 42);       // 5个42: {42, 42, 42, 42, 42}
    
    // 3. 用列表初始化（C++11）
    vector<int> v4 = {1, 2, 3, 4, 5};  // 最常用！
    vector<int> v5{10, 20, 30};        // 省略等号也可以
    
    // 4. 用数组初始化
    int arr[] = {1, 2, 3, 4, 5};
    vector<int> v6(arr, arr + 5);      // 包含5个元素
    
    // 5. 用另一个vector初始化（拷贝构造）
    vector<int> v7(v4);                // 复制v4的所有元素
    
    // 6. 用迭代器范围初始化
    vector<int> v8(v4.begin(), v4.begin() + 3);  // 前3个元素
    
    return 0;
}
```

## 1.3 添加元素（3种方法）

```cpp
vector<int> vec;

// 1. push_back() - 尾部添加（最常用）
vec.push_back(10);  // {10}
vec.push_back(20);  // {10, 20}
vec.push_back(30);  // {10, 20, 30}

// 2. insert() - 任意位置插入（慢！）
// 注意：中间插入需要移动后面所有元素
vec.insert(vec.begin(), 5);      // 开头插入: {5, 10, 20, 30}
vec.insert(vec.begin() + 2, 15); // 位置2插入: {5, 10, 15, 20, 30}

// 3. emplace_back() - 尾部直接构造（C++11，效率更高）
// 对于复杂对象，比push_back更好
vec.emplace_back(40);  // {5, 10, 15, 20, 30, 40}
```

## 1.4 访问元素（4种方法）

```cpp
vector<int> vec = {10, 20, 30, 40, 50};

// 1. operator[] - 最常用，不检查越界
cout << vec[0];     // 10
cout << vec[2];     // 30
vec[1] = 99;        // 修改元素: {10, 99, 30, 40, 50}

// 2. at() - 会检查越界，越界抛异常
cout << vec.at(0);  // 10
// cout << vec.at(10);  // 抛出 std::out_of_range 异常

// 3. front()/back() - 获取头尾元素
cout << vec.front();  // 10（第一个）
cout << vec.back();   // 50（最后一个）

// 4. 通过迭代器
auto it = vec.begin();
cout << *it;  // 10
it++;
cout << *it;  // 20
```

## 1.5 删除元素（3种方法）

```cpp
vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

// 1. pop_back() - 删除最后一个元素
vec.pop_back();  // 删除9: {1, 2, 3, 4, 5, 6, 7, 8}

// 2. erase() - 删除指定位置
vec.erase(vec.begin());      // 删除开头: {2, 3, 4, 5, 6, 7, 8}
vec.erase(vec.begin() + 2);  // 删除位置2: {2, 3, 5, 6, 7, 8}

// 3. erase() - 删除范围[first, last)
vec.erase(vec.begin() + 1, vec.begin() + 3);  // 删除[1,3): {2, 6, 7, 8}

// 4. clear() - 清空所有
vec.clear();  // {}
```

## 1.6 容量相关（重要！理解vector工作原理）

```cpp
vector<int> vec;

cout << "初始状态:" << endl;
cout << "size: " << vec.size() << endl;      // 元素个数: 0
cout << "capacity: " << vec.capacity() << endl; // 容量: 0
cout << "empty: " << vec.empty() << endl;    // 是否空: true

// 添加元素
vec.push_back(1);
cout << "\n添加1个元素后:" << endl;
cout << "size: " << vec.size() << endl;      // 1
cout << "capacity: " << vec.capacity() << endl; // 1

vec.push_back(2);
vec.push_back(3);
cout << "\n添加3个元素后:" << endl;
cout << "size: " << vec.size() << endl;      // 3
cout << "capacity: " << vec.capacity() << endl; // 4（自动扩容！）

// 容量管理
vec.reserve(100);  // 预分配100个元素的空间
cout << "reserve(100)后:" << endl;
cout << "size: " << vec.size() << endl;      // 3
cout << "capacity: " << vec.capacity() << endl; // 至少100

// 调整大小
vec.resize(10, 99);  // 调整为10个元素，新元素初始化为99
cout << "resize(10, 99)后:" << endl;
cout << "size: " << vec.size() << endl;      // 10
cout << "内容: ";
for (int n : vec) cout << n << " ";  // 1 2 3 99 99 99 99 99 99 99
```

## 1.7 vector的内存增长机制

```cpp
vector<int> vec;
cout << "演示vector自动扩容过程:" << endl;

for (int i = 0; i < 20; i++) {
    vec.push_back(i);
    cout << "size: " << vec.size() 
         << ", capacity: " << vec.capacity() << endl;
}

// 输出示例（不同编译器策略不同，但通常翻倍增长）：
// size: 1, capacity: 1
// size: 2, capacity: 2
// size: 3, capacity: 4    ← 第一次扩容
// size: 4, capacity: 4
// size: 5, capacity: 8    ← 第二次扩容
// size: 6, capacity: 8
// size: 7, capacity: 8
// size: 8, capacity: 8
// size: 9, capacity: 16   ← 第三次扩容
```

## 1.8 遍历vector（5种方法）

```cpp
vector<int> vec = {10, 20, 30, 40, 50};

// 1. 下标遍历（最直观）
cout << "方法1 - 下标遍历:" << endl;
for (size_t i = 0; i < vec.size(); i++) {
    cout << vec[i] << " ";
}
cout << endl;

// 2. 范围for循环（C++11，推荐！）
cout << "方法2 - 范围for循环:" << endl;
for (int num : vec) {  // 每次复制元素
    cout << num << " ";
}
cout << endl;

// 3. 范围for循环（引用，避免复制）
cout << "方法3 - 范围for循环(引用):" << endl;
for (int& num : vec) {  // 引用，可修改元素
    cout << num << " ";
    num++;  // 每个元素+1
}
cout << endl;

// 4. 迭代器遍历
cout << "方法4 - 迭代器遍历:" << endl;
for (auto it = vec.begin(); it != vec.end(); ++it) {
    cout << *it << " ";
}
cout << endl;

// 5. 反向迭代器
cout << "方法5 - 反向迭代器:" << endl;
for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
    cout << *it << " ";  // 从后往前
}
cout << endl;
```

## 1.9 二维vector（矩阵）

```cpp
// 创建3行4列的矩阵，初始值全为0
vector<vector<int>> matrix(3, vector<int>(4, 0));

// 赋值
matrix[0][0] = 1;
matrix[1][2] = 5;
matrix[2][3] = 9;

// 遍历打印
cout << "二维vector（矩阵）:" << endl;
for (int i = 0; i < matrix.size(); i++) {        // 行
    for (int j = 0; j < matrix[i].size(); j++) {  // 列
        cout << matrix[i][j] << " ";
    }
    cout << endl;
}

// 锯齿状数组（每行长度不同）
vector<vector<int>> jagged = {
    {1, 2, 3},
    {4, 5},
    {6, 7, 8, 9}
};
```

## 1.10 vector常见错误

```cpp
vector<int> vec = {1, 2, 3, 4, 5};

// 错误1：越界访问
// cout << vec[10];  // 未定义行为！可能崩溃

// 正确：用at()或在访问前检查
if (vec.size() > 10) {
    cout << vec[10];
}

// 错误2：迭代器失效
vector<int> vec2 = {1, 2, 3, 4, 5};
auto it = vec2.begin() + 2;  // it指向3
vec2.push_back(6);           // 可能导致重新分配内存！
// cout << *it;               // 危险！it可能失效

// 正确：在修改后重新获取迭代器
it = vec2.begin() + 2;       // 重新赋值
cout << *it;                 // 安全
```

## 1.11 vector总结表

| 特性 | 说明 |
|------|------|
| **内存布局** | 连续内存，随机访问O(1) |
| **尾部插入** | O(1)（平均），可能触发扩容 |
| **中间插入** | O(n)，需要移动后面元素 |
| **查找元素** | O(n)，需要遍历 |
| **访问元素** | O(1)，通过下标 |
| **适用场景** | 需要随机访问、尾部频繁操作 |
| **不适用** | 频繁在中间插入/删除 |

---

# 2. string - 字符串（特殊的vector<char>）

## 2.1 基本使用

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // 创建字符串
    string s1;                    // 空字符串
    string s2 = "Hello";         // 用C风格字符串初始化
    string s3("World");          // 构造函数
    string s4(5, 'A');           // 5个A: "AAAAA"
    string s5 = s2;              // 拷贝构造
    
    // 常用操作
    string str = "Hello";
    
    // 1. 获取长度
    cout << str.length() << endl;    // 5
    cout << str.size() << endl;      // 5（和length一样）
    
    // 2. 访问字符
    cout << str[0] << endl;          // 'H'
    cout << str.at(1) << endl;        // 'e'
    cout << str.front() << endl;      // 'H'
    cout << str.back() << endl;       // 'o'
    
    // 3. 修改
    str += " World";                  // 追加: "Hello World"
    str.append("!!!");                // 追加: "Hello World!!!"
    str.push_back('!');               // 追加单个字符
    
    // 4. 子串
    string sub = str.substr(6, 5);   // 从位置6开始，取5个字符: "World"
    
    // 5. 查找
    size_t pos = str.find("World");  // 找到返回位置6，找不到返回string::npos
    if (pos != string::npos) {
        cout << "Found at: " << pos << endl;
    }
    
    // 6. 替换
    str.replace(6, 5, "C++");        // 从6开始替换5个字符: "Hello C++!!!"
    
    return 0;
}
```

## 2.2 string与C字符串转换

```cpp
#include <cstring>  // for strlen, strcpy

int main() {
    // string转C字符串
    string str = "Hello";
    const char* cstr = str.c_str();  // 返回const char*
    const char* data = str.data();   // 同样，C++17前返回const char*
    
    // C字符串转string
    const char* hello = "Hello World";
    string s1(hello);                // 直接构造
    string s2 = hello;               // 赋值
    
    // 字符数组转string
    char arr[] = {'H', 'i', '\0'};
    string s3(arr);
    
    return 0;
}
```

---

# 3. array - 静态数组（C++11）

## 3.1 固定大小的数组

```cpp
#include <iostream>
#include <array>  // 必须包含这个头文件
using namespace std;

int main() {
    // 创建array（大小固定，编译时确定）
    array<int, 5> arr1;             // 5个int，未初始化
    array<int, 5> arr2 = {1, 2, 3}; // 前3个初始化，后2个为0
    array<int, 5> arr3{4, 5, 6, 7, 8}; // 全部初始化
    
    // 访问元素
    cout << arr3[0] << endl;        // 4
    cout << arr3.at(1) << endl;     // 5
    cout << arr3.front() << endl;   // 4
    cout << arr3.back() << endl;    // 8
    
    // 遍历
    for (int i = 0; i < arr3.size(); i++) {
        cout << arr3[i] << " ";
    }
    cout << endl;
    
    // 范围for循环
    for (int num : arr3) {
        cout << num << " ";
    }
    cout << endl;
    
    // array的优势：知道大小，不会越界（at会检查）
    // arr3[10];  // 错误！编译时报错（相比vector，array更安全）
    
    return 0;
}
```

---

# 4. map - 键值对（红黑树实现）

## 4.1 基本概念
`map`是有序键值对容器，基于**红黑树**实现，键是唯一的。

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    // 创建map
    map<string, int> scores;  // 键是string，值是int
    
    // 插入元素（4种方法）
    // 方法1：用[]运算符（最常用）
    scores["Alice"] = 95;    // 如果不存在则创建
    scores["Bob"] = 87;
    scores["Charlie"] = 92;
    
    // 方法2：insert
    scores.insert({"David", 88});  // C++11
    // 或
    scores.insert(pair<string, int>("Eve", 90));
    // 或
    scores.insert(make_pair("Frank", 85));
    
    // 方法3：emplace（C++11，直接构造，避免临时对象）
    scores.emplace("Grace", 93);
    
    // 访问元素
    cout << "Alice: " << scores["Alice"] << endl;  // 95
    
    // 修改元素
    scores["Alice"] = 96;  // 修改已存在的键
    
    // 查找元素
    auto it = scores.find("Bob");
    if (it != scores.end()) {
        cout << "Found Bob: " << it->second << endl;
    }
    
    // 检查元素是否存在
    if (scores.count("Charlie") > 0) {
        cout << "Charlie exists" << endl;
    }
    
    // 遍历map（按键自动排序）
    cout << "\nAll scores (sorted by name):" << endl;
    for (const auto& pair : scores) {
        cout << pair.first << ": " << pair.second << endl;
    }
    // 输出：Alice, Bob, Charlie...（按字母顺序）
    
    // 删除元素
    scores.erase("Bob");  // 删除键为"Bob"的元素
    
    return 0;
}
```

## 4.2 map的迭代器

```cpp
map<string, int> scores = {
    {"Alice", 95},
    {"Bob", 87},
    {"Charlie", 92}
};

// 遍历方法1：范围for循环
for (const auto& entry : scores) {
    cout << entry.first << ": " << entry.second << endl;
}

// 遍历方法2：迭代器
for (auto it = scores.begin(); it != scores.end(); ++it) {
    cout << it->first << ": " << it->second << endl;
}

// 遍历方法3：结构化绑定（C++17）
for (const auto& [name, score] : scores) {
    cout << name << ": " << score << endl;
}
```

## 4.3 map特性

```cpp
map<string, int> m;

// 1. 自动排序
m["banana"] = 3;
m["apple"] = 5;
m["cherry"] = 2;

for (const auto& p : m) {
    cout << p.first << " ";  // apple banana cherry（已排序！）
}

// 2. 键必须唯一
m["apple"] = 5;   // 设置值为5
m["apple"] = 10;  // 修改值为10，不是添加新元素
cout << m.size();  // 3，不是4

// 3. 自定义比较函数
struct CaseInsensitiveCompare {
    bool operator()(const string& a, const string& b) const {
        // 不区分大小写比较
        string a_lower = a;
        string b_lower = b;
        transform(a_lower.begin(), a_lower.end(), a_lower.begin(), ::tolower);
        transform(b_lower.begin(), b_lower.end(), b_lower.begin(), ::tolower);
        return a_lower < b_lower;
    }
};

map<string, int, CaseInsensitiveCompare> caseInsensitiveMap;
caseInsensitiveMap["Apple"] = 5;
caseInsensitiveMap["apple"] = 10;  // 这会被认为是同一个键！
cout << caseInsensitiveMap.size();  // 1
```

---

# 5. unordered_map - 哈希表（C++11）

## 5.1 无序映射

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    // unordered_map用法和map类似，但不自动排序
    unordered_map<string, int> scores;
    
    // 插入元素
    scores["Alice"] = 95;
    scores["Bob"] = 87;
    scores["Charlie"] = 92;
    scores["David"] = 88;
    
    // 遍历（顺序不确定）
    cout << "unordered_map (顺序不确定):" << endl;
    for (const auto& pair : scores) {
        cout << pair.first << ": " << pair.second << endl;
    }
    
    // 性能更好：查找O(1)，插入O(1)平均
    // 但内存占用更大，迭代顺序不确定
    
    return 0;
}
```

## 5.2 map vs unordered_map对比

| 特性 | map | unordered_map |
|------|-----|---------------|
| **实现** | 红黑树 | 哈希表 |
| **时间复杂度** | 查找O(log n) | 查找O(1)平均，O(n)最坏 |
| **内存** | 较少 | 较多（哈希表有桶） |
| **顺序** | 按键排序 | 无序 |
| **使用场景** | 需要有序遍历 | 需要快速查找，不关心顺序 |

---

# 6. set - 集合（自动去重、排序）

## 6.1 集合基本操作

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // set存储唯一元素，自动排序
    set<int> numbers;
    
    // 插入元素
    numbers.insert(3);
    numbers.insert(1);
    numbers.insert(4);
    numbers.insert(1);  // 重复，不会被插入
    numbers.insert(2);
    
    // 遍历（自动排序）
    cout << "Set elements (sorted): ";
    for (int num : numbers) {
        cout << num << " ";  // 1 2 3 4
    }
    cout << endl;
    
    // 查找
    auto it = numbers.find(3);
    if (it != numbers.end()) {
        cout << "Found 3" << endl;
    }
    
    // 检查是否存在
    if (numbers.count(2) > 0) {
        cout << "2 exists" << endl;
    }
    
    // 删除
    numbers.erase(3);
    
    // 获取大小
    cout << "Size: " << numbers.size() << endl;
    
    return 0;
}
```

## 6.2 集合运算

```cpp
set<int> A = {1, 2, 3, 4, 5};
set<int> B = {4, 5, 6, 7, 8};

// 并集
set<int> union_set;
set_union(A.begin(), A.end(),
          B.begin(), B.end(),
          inserter(union_set, union_set.begin()));
// union_set: {1, 2, 3, 4, 5, 6, 7, 8}

// 交集
set<int> intersection_set;
set_intersection(A.begin(), A.end(),
                 B.begin(), B.end(),
                 inserter(intersection_set, intersection_set.begin()));
// intersection_set: {4, 5}

// 差集 (A - B)
set<int> difference_set;
set_difference(A.begin(), A.end(),
               B.begin(), B.end(),
               inserter(difference_set, difference_set.begin()));
// difference_set: {1, 2, 3}
```

---

# 7. 容器选择指南

## 7.1 根据需求选择容器

```cpp
// 场景1：需要快速随机访问
vector<int> vec;  // ✅ 最佳选择
// 访问 vec[1000] 是 O(1)

// 场景2：需要快速查找（按键）
unordered_map<string, int> phonebook;  // ✅ 哈希表，查找O(1)
// phonebook["Alice"] 快速查找

// 场景3：需要有序遍历
map<int, string> sortedData;  // ✅ 红黑树，自动排序
// 遍历时按键顺序

// 场景4：只需要判断是否存在
set<string> dictionary;  // ✅ 自动去重
// dictionary.count(word) 快速判断是否存在

// 场景5：频繁在两端插入删除
deque<int> dq;  // ✅ 双端队列
// dq.push_front(), dq.push_back()

// 场景6：频繁在中间插入删除
list<int> lst;  // ✅ 双向链表
// 插入删除O(1)，但访问O(n)
```

## 7.2 总结表格

| 容器 | 底层实现 | 访问 | 插入/删除 | 查找 | 内存 | 有序 |
|------|---------|------|-----------|------|------|------|
| `vector` | 动态数组 | O(1)随机 | 尾部O(1)，中间O(n) | O(n) | 少 | 插入顺序 |
| `deque` | 分块数组 | O(1)随机 | 头尾O(1)，中间O(n) | O(n) | 中 | 插入顺序 |
| `list` | 双向链表 | O(n) | 任意位置O(1) | O(n) | 多 | 插入顺序 |
| `set` | 红黑树 | 遍历O(n) | O(log n) | O(log n) | 中 | 按键排序 |
| `map` | 红黑树 | 遍历O(n) | O(log n) | O(log n) | 中 | 按键排序 |
| `unordered_set` | 哈希表 | 遍历O(n) | O(1)平均 | O(1)平均 | 多 | 无序 |
| `unordered_map` | 哈希表 | 遍历O(n) | O(1)平均 | O(1)平均 | 多 | 无序 |

---

# 8. 实战练习

## 练习1：统计单词频率

```cpp
#include <iostream>
#include <map>
#include <string>
#include <sstream>
using namespace std;

int main() {
    string text = "apple banana apple orange banana apple";
    
    map<string, int> wordCount;
    stringstream ss(text);
    string word;
    
    // 统计每个单词出现次数
    while (ss >> word) {
        wordCount[word]++;  // 如果不存在会创建并初始化为0
    }
    
    // 输出结果
    cout << "单词频率统计:" << endl;
    for (const auto& [w, count] : wordCount) {
        cout << w << ": " << count << endl;
    }
    
    return 0;
}
```

## 练习2：学生成绩管理系统

```cpp
#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main() {
    // 学生姓名 -> 成绩列表
    map<string, vector<int>> studentScores;
    
    // 添加成绩
    studentScores["Alice"] = {95, 88, 92};  // 初始化
    studentScores["Bob"].push_back(78);     // 添加
    studentScores["Bob"].push_back(85);
    studentScores["Charlie"] = {90, 92, 94, 88};
    
    // 计算平均分
    cout << "学生平均成绩:" << endl;
    for (auto& [name, scores] : studentScores) {
        int sum = 0;
        for (int score : scores) {
            sum += score;
        }
        double average = static_cast<double>(sum) / scores.size();
        cout << name << ": " << average << endl;
    }
    
    return 0;
}
```

---

# 最后的核心要点

## 必须掌握的：
1. **vector** - 80%的情况都用它
2. **map/unordered_map** - 键值对存储
3. **string** - 字符串处理

## 需要了解的：
4. **set** - 去重和集合运算
5. **array** - 固定大小数组

## 不常用的：
6. **list/deque** - 特定场景使用
7. **forward_list** - 单链表，很少用

## 记住的黄金法则：
1. 需要**快速随机访问** → `vector`
2. 需要**快速查找（按键）** → `unordered_map`（无序）或`map`（有序）
3. 需要**自动去重+排序** → `set`
4. 不确定用什么时 → 先用`vector`，不够再换

